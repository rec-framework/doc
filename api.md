# Rec JavaScript API

* TOC
{:toc}

Rec using a updated version Rhino as JavaScript engine, it support
several ES6 features to help you for better development experience.

# Standard interface definitions

Standadrd interfaces is defined in following files:

[`rec.d.ts`](https://github.com/rec-framework/rec-core/blob/master/rec-core/src/main/resources/rec.d.ts)
```typescript
interface Record {
    get(value: string): string;
    keys(): string[];
}

interface Stream { // Java8 stream

}

interface Source {
    tee(tee: Tee): Source;
    to(target: Target);
    filter(predicate: WrappedPredicate<Record>): Source
}

interface Target {
    tee(tee: Tee): Target;
}

interface Tee {
    source(): Source;
}

interface StatefulTee<T> extends Tee {
    state: T
}

interface ItemCounterTee extends Tee {
    count: number;
}

interface CollectTee<T> extends Tee {
    collect(): T;
}

interface WrappedPredicate<T> {
    test(value: T): boolean
}

interface WrappedAction<T> {
    apply(value: T): void
}

export module rec {
    function pred<T>(pred: (any: T) => boolean): WrappedPredicate<T>;

    function action<T>(func: (any: T) => void): WrappedAction<T>;

    function println(...args: any[]);

    //source
    function csv(source: string, format: string): Source;

    function stream(stream: Stream): Source;

    // target
    function target(func: (record: Record) => void): Target;

    function flat(file: string): Target;

    function dummy(): Target;

    //tee
    function counter(condition: (Record) => boolean): ItemCounterTee;

    function unique(...fields: string[]): Tee;

    function stateless(func: (record: Record) => void): Tee;

    function stateful<T>(state: T, reducer: (record: Record, state: T) => T): StatefulTee<T>;

    function cache(size: number): Tee;

    function collect<T>(collection: T): CollectTee<T>;
}
```

# Core concepts

## Record

Rec has several core concepts to represent data and related stuff, core idea
is represent each data entry as a `Record`.
```typescript
interface Record {
    get(value: string): string;
    keys(): string[];
}
```

Basically a record is just a string-indexed-value object, which has specific
schema, i.e. the accessor expression, to get the values.

in JavaScript, the records can be accessed as a JavaScript Object, like if
you have a Record contains key `name` and `address`, you can just using let
destructive assignment:
```javascript
let {name, address} = <the record>;
```

Also a record have the `keys` method to get all it's accessible keys, and
this can be easily to encode a record using `JSON.stringify`.

## Source, Target and Tee

Other important concepts are the processing components, in Rec, there are
3 different components to support different processing scenarios: the `Source`,
to obtain data; the `Target`, to save/transfer data; and `Tee`, to add processor
in middle.

### Source

`Source` is the component to obtain data, e.g. a CSV file, or a server socket.

A source can be generated from a Rec method, or generated by a existing source
object. Once it is generated, the existing source is considered as parent of 
the new one, and new one considered as child of existing one.

It is important to understand that a source is not reentrant, once you direct
a source to a target, neither it's child source or parent source is no longer
valid. And this invalid status is related, meaning, if it's child is
invalid, the parent should also be invalid, or vice versa.

Each source have 3 different methods:
```javascript
Source#to(target: Target)
```
Direct the source to a specific target, either it is a blocking process to put
all data to the target, or it is a non-blocking process to reactively call the
target when the source got data.

```javascript
Source#tee(tee: Tee): Source
```
Attach a tee to a source, this will create a new source, which is lazy / reactive
based on the implementation of source.

```javascript
Source#filter(predicate: WrappedPredicate<Record>): Source
```
Attach a filter to a source, this will using a predicate, as this is a plain Java
method, so you need call `Rec#pred` method first to wrap a JavaScript predicate
function.

This method will create a new source.

### Target

A target represents the destination of data, e.g. a consumer function, or a database
connection (to save the data).

A target can be reused many time, and can attach a tee.
```javascript
Target#tee(tee: Tee): Target
```
`Target#tee` will create a new Target object, but the previous object is still available
to use.

### Tee

Tee is to represent the process in-middle of data aquiring and saving, like a T joint
pipe (and that's the origin of it's name), e.g., saving the intermediate result, or
do some aggregating/validating process. 

A tee can be easily convert to a source if it contains aggregated data.

